#include "tasks.h"
#include "sched.h"
#include "mm.h"
#include "kernel.h"
#include "errno.h"
#include "system.h"
#include "string.h"
#include "types.h"

long last_pid=0;

int find_empty_process(void)
{
    int i;

repeat:
    if ((++last_pid)<0) {
        last_pid = 1;
    }

    for(i=0 ; i<NR_TASKS ; i++) {
        if (task[i] && task[i]->pid == last_pid) {
            goto repeat;
        }
    }

    for(i=1 ; i<NR_TASKS ; i++) {
        if (!task[i]) {
            return i;
        }
    }

    printk("Kernel error: PID esauriti\n");
    return -EAGAIN;
}

int copy_process(int nr, long ebp, long edi, long esi, long gs, long none,
                 long ebx,long ecx,long edx,
				 long ret,
                 long gs2, long fs, long es,
				 long ds, long edi2,
				 long esi2, long ebp2, long esp2,
                 long ebx2, long edx2, long ecx2,
				 long eax2, long esp, long cs,
                 long eip, long eflags, long ss)
{
    struct task_struct *p;
	char *prg_mem;
    long flags;

/*
	printk("AX =%x\n",  nr);
	printk("EBP=%x\n", ebp);
	printk("EDI=%x\n", edi);
	printk("ESI=%x\n", esi);
	printk("GS =%x\n",  gs);
	printk("EBX=%x\n", ebx);
	printk("ECX=%x\n", ecx);
	printk("EDX=%x\n", edx);
*/
	printk("GS2=%x\n", gs2);
    printk("FS=%x\n", fs);
	printk("DS=%x\n", ds);
	printk("ES=%x\n", es);

	printk("EDI2=%x\n", edi2);
	printk("ESI2=%x\n", esi2);
    printk("EBP2=%x\n", ebp2);
	printk("ESP2=%x\n", esp2);
	printk("EBX2=%x\n", ebx2);
	printk("EDX2=%x\n", edx2);
	printk("ECX2=%x\n", ecx2);
	printk("EAX2=%x\n", eax2);
	printk("ESP=%x\n", esp);
	printk("CS=%x\n", cs);

	printk("EIP=%x\n", eip);
	printk("CS=%x\n", cs);
	printk("EFLAGS=%x\n", eflags);
	printk("ESP=%x\n", esp);
	printk("SS=%x\n", ss);

	while(1);
    save_flags(flags); cli();

    p = (struct task_struct *) get_free_page();

    if (!p) {
        restore_flags(flags);
	    return -ENOMEM;
	}

	// allocate memory for code/data
	prg_mem = (char *) get_free_page();
    
	if (!prg_mem) {
        free_page(p);
	    restore_flags(flags);
        return -ENOMEM;
	}

    // clean memory and copy process data
	memset(prg_mem, 0, PAGE_SIZE);
	memcpy(prg_mem, (char *) get_base(current->ldt[1]), PAGE_SIZE);

    // copy descriptor	
    *p = *current;
    p->pid = last_pid;
	p->counter = p->priority;

    // set up LDT
    set_code_desc(&(p->ldt[1]), (u_long)prg_mem, PAGE_SIZE-1);
    set_data_desc(&(p->ldt[2]), (u_long)prg_mem, PAGE_SIZE-1);

	// setup TSS
    p->tss.back_link = 0;
    p->tss.esp0 = PAGE_SIZE + (long) p;
    p->tss.ss0 = DS_SEL;

	p->tss.esp1 = 0;
	p->tss.ss1 = 0;
	p->tss.esp2 = 0;
	p->tss.ss2 = 0;
	p->tss.cr3 = 0;

    p->tss.eip = eip;
    p->tss.eflags = eflags;

    p->tss.eax = 0;
    p->tss.ecx = ecx;
    p->tss.edx = edx;
    p->tss.ebx = ebx;

    p->tss.esp = esp;
    p->tss.ebp = ebp;
    p->tss.esi = esi;
    p->tss.edi = edi;

    p->tss.es = es & 0xffff;
    p->tss.cs = cs & 0xffff;
    p->tss.ss = ss & 0xffff;
    p->tss.ds = ds & 0xffff;
    p->tss.fs = fs & 0xffff;
    p->tss.gs = gs & 0xffff;

    p->tss.ldt = _LDT(nr);
	p->tss.trace = 0;
	p->tss.bitmap = 0xDFFF;
	p->tss.tr = _TSS(nr);

    set_tss_desc(gdt+(nr<<1)+FIRST_TSS_ENTRY, &(p->tss));
    set_ldt_desc(gdt+(nr<<1)+FIRST_LDT_ENTRY, &(p->ldt), 3);
    task[nr] = p;

	restore_flags(flags);
	return last_pid;
}

